{"version":3,"sources":["components/AddCategory.js","helpers/getGifs.js","components/GifGridItem.js","components/GifGrid.js","hooks/useFetchImages.js","GifExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","e","preventDefault","console","log","trim","categs","type","value","onChange","target","placeholder","getGifs","category","a","url","encodeURI","fetch","response","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","resolve","useFetchImages","image","GifExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"2MAUaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EAiBVC,mBAAS,IAjBC,mBAiBvCC,EAjBuC,KAiB3BC,EAjB2B,KA+C9C,OAKI,cAJA,CAIA,QAAMC,SA1BW,SAACC,GAElBA,EAAEC,iBAEFC,QAAQC,IAAI,UAMRN,EAAWO,SAKXT,GAAc,SAAAU,GAAM,OAAKR,GAAL,mBAAoBQ,OAExCP,EAAc,MASlB,UAKI,6BAAMD,IAGN,uBACIS,KAAK,OAELC,MAAOV,EAKPW,SAjDc,SAACR,GAGvBF,EAAcE,EAAES,OAAOF,QAiDfG,YAAY,iC,+BChFfC,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAKbC,EALa,iDAKoCC,UAAUH,GAL9C,oIAQII,MAAMF,GARV,cAQbG,EARa,gBAcIA,EAASC,OAdb,uBAcXC,EAdW,EAcXA,KAGFC,EAAOD,EAAKE,KAAI,SAAAC,GAAQ,IAAD,EACzB,MAAO,CACHC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MACXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QArBvB,kBA4BZM,GA5BY,4CAAH,sDCIPO,EAAc,SAAC,GAAqB,EAApBJ,GAAqB,IAAjBC,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IAIpC,OAFAZ,QAAQC,IAAIqB,GAMR,cAHA,CAGA,OAAKI,UAAU,yCAAf,UAGI,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,4BAAKA,QCTJO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECDX,SAACA,GAAa,MAEdhB,mBAAS,CAC/BuB,KAAM,GACNa,SAAS,IAJ2B,mBAEjCC,EAFiC,KAE1BC,EAF0B,KAyCxC,OAvBAC,qBAAU,WAEFxB,EAAQC,GAAUwB,MAAK,SAAAC,GAYnBH,EAAS,CACLf,KAAMkB,EACNL,SAAS,SAItB,CAACpB,IAGGqB,ED0C0BK,CAAe1B,GAAxCoB,EAlF6B,EAkF7BA,QAAcP,EAlFe,EAkFpBN,KAGjB,OAEI,cADA,CACA,sBAKA,oBAAIS,UAAU,oCAAd,SAAoDhB,IAuDlDoB,GAAW,mBAAGJ,UAAU,mCAAb,yBAEb,qBAAKA,UAAU,YAAf,SAIQH,EAAOJ,KAAI,SAACkB,GACR,OAAKA,EAAMf,MAIP,cAAC,EAAD,eAEQe,GADCA,EAAMhB,IAJR,YEtEhBiB,EAtFM,WAAM,MAQa5C,mBAAS,CAAC,gBARvB,mBAQhB6C,EARgB,KAQJ9C,EARI,KA0CvB,OACI,qCACI,8CAMA,cAAC,EAAD,CAAaA,cAAgBA,IAE7B,uBAQA,6BAeM8C,EAAWpB,KAAI,SAAAT,GAAQ,OACrB,cAAC,EAAD,CAEIA,SAAWA,GADLA,YCzE9B8B,IAASC,OAGL,cAAC,EAAD,IAEFC,SAASC,eAAe,W","file":"static/js/main.04f5860d.chunk.js","sourcesContent":["//Snippet -> rafc\r\nimport React, { useState } from 'react';\r\n\r\nimport { PropTypes } from 'prop-types';\r\n\r\n\r\n//UpperCamelCase (más conocido como PascalCase) para saber que es un componente\r\n// export const AddCategory = () => {\r\n\r\n// Recibir función desde el padre y con destructuración asignarle el nombre\r\nexport const AddCategory = ({ setCategories }) => {\r\n\r\n    // Tarea 2\r\n    //     Recibir la función de agregar categoría\r\n    //     Agregar una categoría al presionar enter\r\n\r\n    // Tarea 3\r\n    // Agregar propTypes para requerir la función desde el padre\r\n    // Validar el error cuando no se envía\r\n\r\n    //Quitamos el valor inicial, esto dará un error nuevo en consola porque inputValue va a ser undefined y se necesita un valor en <input ... value={inputValue} ... />>\r\n    // const [inputValue, setInputValue] = useState('Valor inicial');\r\n\r\n    // Para mostrar el error de valor undefined\r\n    // const [inputValue, setInputValue] = useState();\r\n\r\n    // Para corregir el error de undefined que es lo mismo que se hacia en angular, dar un valor inicial\r\n    const [inputValue, setInputValue] = useState('');\r\n\r\n    const handleInputChange = (e) => {\r\n        // Para visualizar el value desde el target del evento\r\n        // console.log(e.target.value);\r\n        setInputValue(e.target.value);\r\n    }\r\n\r\n    // Para manejar presionar enter\r\n    const handleSubmit = (e) => {\r\n        // Para prevenir el comportamiento por defecto del evento\r\n        e.preventDefault();\r\n\r\n        console.log('Submit');\r\n\r\n        //Invocar la función recibida desde el padre y utilizarla a través del callback porque no tenemos acceso a categories, se puede recibir también las categories pero gracias al callback podemos pedirlas\r\n        // setCategories(categs => [...categs, inputValue]);\r\n\r\n        // Agregar validaciones porque acepta vacíos\r\n        if (inputValue.trim()) {\r\n            // Quitar agregar al final para que se vayan agregando al inicio\r\n            // setCategories(categs => [...categs, inputValue]);            \r\n\r\n            // Quitar agregar al final para que se vayan agregando al inicio\r\n            setCategories(categs => [inputValue, ...categs]);            \r\n\r\n            setInputValue('');\r\n        }\r\n    }\r\n\r\n    return (\r\n        // Quitamos <> porque forms ya engloba todos los demás tags\r\n        // <>\r\n\r\n        // Agregamos form para poder utilizar el evento submit\r\n        <form onSubmit={ handleSubmit }>\r\n            {/* Para verificar el componente, como AddCategory works!!! en angular */}\r\n            {/* <h2>AddCategory</h2> */}\r\n\r\n            {/* Agregar para mostrar el valor */}\r\n            <h1>{ inputValue }</h1>\r\n\r\n            {/* Agregar CSS si se quiere */}\r\n            <input \r\n                type=\"text\" \r\n                // Produce un error ya que quieres editar un valor inmutable (inputValue)\r\n                value={inputValue}\r\n                // Quita el error pero aún no es editable, debemos crear un manejador para ese evento y allí actualizarlo con el useState (setInputValue)\r\n                // onChange={ (e) => console.log(e) }\r\n\r\n                // El evento llama a handleInputChange para actualizar, como es solo una instrucción y recibe e de evento no es necesaria la expresión lambda\r\n                onChange={ handleInputChange }\r\n\r\n                // Agregar placeholder después de quitar el valor por defecto\r\n                placeholder=\"Ingrese una categoría\"\r\n            />\r\n        </form>\r\n        // </>\r\n    )\r\n}\r\n\r\nAddCategory.propTypes = {\r\n    setCategories:PropTypes.func.isRequired\r\n}","// Como es una función async nos va a devolver una promesa\r\nexport const getGifs = async (category) => { \r\n    // Comentar para agregar la categoría que llega por props luego de las clases\r\n    // const url = 'https://api.giphy.com/v1/gifs/search?q=saint+seiya&limit=20&offset=5&rating=g&lang=en&random_id=e826c9fc5c929e0d6c6d423841a282aa&api_key=WzZmmeMbM2fIoV97Bv3ZDXYM6pE1MDa6';\r\n\r\n    // Agregar la categoría que llega por props y usar encodeURI() para sanitizar el string. También cambiar en AddCategory() para que agregue las nuevas búsquedas al inicio del arreglo\r\n    const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category) }&limit=10&offset=5&rating=g&lang=en&random_id=e826c9fc5c929e0d6c6d423841a282aa&api_key=WzZmmeMbM2fIoV97Bv3ZDXYM6pE1MDa6`;\r\n\r\n    //Hacer una llamada http\r\n    const response = await fetch(url);\r\n\r\n    //Trae toda la data con envoltorio incluido\r\n    // const data = await response.json();\r\n\r\n    //Destructurar para obtener la data sin envoltorio porque la estructura es obj.data\r\n    const { data } = await response.json();\r\n\r\n    //Usar map para recorrer la data y solo sacar lo que necesitamos\r\n    const gifs = data.map(img => {\r\n        return {\r\n            id: img.id,\r\n            title: img.title,\r\n            url: img.images?.downsized_medium.url\r\n        }\r\n    });\r\n\r\n    //Comentar una vez que funciona para que no estorbe en la ejecución del custom hook\r\n    // console.log(gifs);\r\n\r\n    return(gifs);\r\n}\r\n","import React from 'react';\r\n\r\n// export const GifGridItem = (props) => {\r\n\r\n//Para no usar en el componente props.image enviamos destructurado el objeto\r\nexport const GifGridItem = ({id, title, url}) => {\r\n\r\n    console.log(title);\r\n\r\n    return (\r\n        // <div className=\"card animate__animated animate__bounce\">\r\n\r\n        // Agregar animate.css\r\n        <div className=\"card animate__animated animate__fadeIn\">\r\n            {/* Para revisar si llegó la imagen */}\r\n            {/* { title } */}\r\n            <img src={url} alt={title} />\r\n            <p>{ title }</p>\r\n        </div>\r\n    )\r\n}\r\n","// import React, { useState, useEffect } from 'react';\r\n// import { GifGridItem } from './GifGridItem';\r\n// import { getGifs } from '../helpers/getGifs';\r\n\r\nimport React from 'react';\r\nimport { useFetchImages } from '../hooks/useFetchImages';\r\nimport { GifGridItem } from './GifGridItem';\r\n\r\nexport const GifGrid = ({ category }) => {\r\n\r\n    //Para explicar el problema de llamar el método getGifs() desde la raíz del componente. Crea un bucle al actualizar count y refrescar el componente. Se utiliza useEffect para ejecutar código en ciertos momentos\r\n    // const [count, setCount] = useState(0);\r\n\r\n    //El primer parámetro es una función donde va el código a ejecutar. El segundo parámetro es una lista de dependencias. \r\n    //[] es que solo se ejecute una vez, como el constructor\r\n    //El warning que empezará a aparecer es porque useEffect detecta que hay el parámetro category y que podría cambiar por lo que sugiere agregarlo como dependencia para que se vuelva a ejecutar el código si category cambia, en este caso no se necesita porque la lógica no va de ese modo. En caso de necesitarse sería [category] como dependencia en el segundo parámetro\r\n    // useEffect(() => {\r\n    //     // Comentar para utilizar el helper getGif\r\n    //     // getGifs();\r\n\r\n    //     //Forma larga\r\n    //     // getGifs(category).then((resolve, reject) => {\r\n    //     //     setImages(resolve);\r\n    //     // });\r\n\r\n    //     //Forma corta porque getGifs() solo recibe un parámetro y por defecto le pasa resolve\r\n    //     //Luego de esto comentar lo siguiente para implementar el custom hook:\r\n    //     // - useState\r\n    //     // - useEffect\r\n    //     // - div\r\n    //     // import React, { useState, useEffect } from 'react';\r\n    //     // import { GifGridItem } from './GifGridItem';\r\n    //     // import { getGifs } from '../helpers/getGifs';\r\n    //     // Dejar unicamente el import del react\r\n        //     getGifs(category).then(setImages);\r\n    // }, []);\r\n\r\n    // //Para manejar las imágenes y luego realizar la tarea\r\n    // const [images, setImages] = useState([]);\r\n\r\n\r\n    // const getGifs = () => { \r\n\r\n    // //Convertir en función asíncrona\r\n    // const getGifs = async () => { \r\n    //     // Comentar para agregar la categoría que llega por props luego de las clases\r\n    //     // const url = 'https://api.giphy.com/v1/gifs/search?q=saint+seiya&limit=20&offset=5&rating=g&lang=en&random_id=e826c9fc5c929e0d6c6d423841a282aa&api_key=WzZmmeMbM2fIoV97Bv3ZDXYM6pE1MDa6';\r\n\r\n    //     // Agregar la categoría que llega por props y usar encodeURI() para sanitizar el string. También cambiar en AddCategory() para que agregue las nuevas búsquedas al inicio del arreglo\r\n    //     const url = `https://api.giphy.com/v1/gifs/search?q=${ encodeURI(category) }&limit=20&offset=5&rating=g&lang=en&random_id=e826c9fc5c929e0d6c6d423841a282aa&api_key=WzZmmeMbM2fIoV97Bv3ZDXYM6pE1MDa6`;\r\n\r\n    //     //Hacer una llamada http\r\n    //     const response = await fetch(url);\r\n\r\n    //     //Trae toda la data con envoltorio incluido\r\n    //     // const data = await response.json();\r\n\r\n    //     //Destructurar para obtener la data sin envoltorio porque la estructura es obj.data\r\n    //     const { data } = await response.json();\r\n\r\n    //     //Usar map para recorrer la data y solo sacar lo que necesitamos\r\n    //     const gifs = data.map(img => {\r\n    //         return {\r\n    //             id: img.id,\r\n    //             title: img.title,\r\n    //             url: img.images?.downsized_medium.url\r\n    //         }\r\n    //     });\r\n\r\n    //     setImages(gifs);\r\n\r\n    //     console.log(gifs);\r\n    // }\r\n\r\n    // Para explicar el problema de llamar el método getGifs() desde la raíz del componente.\r\n    // getGifs();\r\n\r\n    //Aquí llamamos al custom hook useFetchImages\r\n    // const state = useFetchImages();\r\n    // console.log(state);\r\n\r\n    //Destructurar useFetchImages\r\n    // const { loading, data } = useFetchImages();\r\n    // console.log(loading);\r\n    // console.log(data);\r\n\r\n    //Agregar la categoría para que el hook sepa que buscar\r\n    // const { loading, data } = useFetchImages(category);\r\n\r\n    // Agregar la referencia images a data para cambiar el nombre\r\n    const { loading, data:images } = useFetchImages(category);\r\n\r\n\r\n    return (\r\n        // Cambiar por el div para aplicar clases y luego volver a habilitar para poder tener el h3 y el div\r\n        <>\r\n\r\n        {/* <h3>{ category }</h3> */}\r\n\r\n        {/* Agregar animación */}\r\n        <h3 className=\"animate__animated animate__fadeIn\">{ category }</h3>\r\n\r\n        {/* Agregar luego de llamar al custom hook useFetchImages */}\r\n        {/* Agregar el setTimeout en el hook para mostrar como cambia el mensaje cargado */}\r\n        {/* Quitar cuando se use la data */}\r\n        {/* { loading ? 'Cargando...' : 'Data cargada' } */}\r\n\r\n        {/* <div className=\"card-grid\"> */}\r\n\r\n            {/* Mover fuera del div para que no le afecte el estilo */}\r\n            {/* <h3>{ category }</h3> */}\r\n\r\n            {/* Para explicar el problema de llamar el método getGifs() desde la raíz del componente. */}\r\n            {/* <h3>{ count }</h3>\r\n            <button onClick={ () => setCount(count + 1) } >Click</button> */}\r\n\r\n            {/* Tarea 4\r\n            Una vez pasados los gifs a través del setImages llenar la lista usando el id como key y el title como valor */}\r\n\r\n            {/* Comentar toda la lista ordenada para reemplazar con el componente GifGridItem */}\r\n            {/* <ol> */}\r\n                {/* <li>sfasdfasdf</li> */}\r\n                {\r\n                    // images.map(({id, title}) => {\r\n                    //     if (title) {\r\n                    //         return (<li key={ id }>{ title }</li>);\r\n                    //     }\r\n                    // })\r\n                }\r\n            {/* </ol> */}\r\n\r\n            {\r\n                // images.map((image) => {\r\n                //     if (!image.title) {\r\n                //         return '';\r\n                //     }\r\n                //     return (\r\n                //         <GifGridItem \r\n                //             key={image.id}\r\n                //             // image={ image } \r\n\r\n                //             //Para no usar en el componente props.image enviamos destructurado el objeto\r\n                //             {...image}\r\n                //         />\r\n                //     );                    \r\n                // })\r\n            }\r\n\r\n        {/* </div> */}\r\n\r\n        {/* Acualizar el div con la data que llega desde el custom hook y agregar un nuevo loader */}\r\n        {/* Este loading usa un operador lógico and y evalúa si ambas son verdaderas y así presenta el mensaje */}\r\n        {/* { loading && <p>Cargando...</p> } */}\r\n\r\n        {/* Agregar animación         */}\r\n        { loading && <p className=\"animate__animated animate__flash\">Cargando...</p> }\r\n\r\n        <div className=\"card-grid\">\r\n        {\r\n                // Cambiar de data a images mediante la referencia :images\r\n                // data.map((image) => {\r\n                images.map((image) => {\r\n                    if (!image.title) {\r\n                        return '';\r\n                    }\r\n                    return (\r\n                        <GifGridItem \r\n                            key={image.id}\r\n                            {...image}\r\n                        />\r\n                    );                    \r\n                })\r\n            }\r\n        </div>\r\n\r\n        {/* Cambiar por el div para aplicar clases y luego volver a habilitar*/}\r\n        </>\r\n    )\r\n}\r\n","import { useState, useEffect } from 'react';\r\nimport { getGifs } from '../helpers/getGifs';\r\n\r\n//Snippet => rafc y luego borrar el import porque no se necesita react para JSX y quitar el return\r\n// export const useFetchImages = () => {\r\n\r\n//Recibir la categoría\r\nexport const useFetchImages = (category) => {\r\n        //Se usa state porque el hook no sabe para que va a trabajar y por convención se usa state en lugar de otro nombre de variable\r\n    const [state, setState] = useState({\r\n        data: [],\r\n        loading: true\r\n    });\r\n\r\n    //Agregar el setTimeout para mostrar como cambia el mensaje cargado\r\n    // setTimeout( () =>  {\r\n    //     setState({\r\n    //         data: [1,2,3,4,5,6],\r\n    //         loading: false    \r\n    //     });\r\n    // }, 3000);\r\n\r\n    // Comentar el setTimeout\r\n    //Agergar el useEffect para controlar que solo se ejecute cuando queremos, en esta ocasión cuando cambia la categoría\r\n    //Los useEffect no pueden ser async, siempre esperan un valor síncrono\r\n    useEffect(() => {\r\n\r\n            getGifs(category).then(resolve => {\r\n\r\n                //Agregarmos el setTimeout solo para ver como se ejecuta\r\n                //Comentar al final y solo hacer el useState\r\n                // setTimeout( () =>  {\r\n                //     console.log(resolve);\r\n                //     setState({\r\n                //         data: resolve,\r\n                //         loading: false\r\n                //     });\r\n                // }, 3000);\r\n\r\n                setState({\r\n                    data: resolve,\r\n                    loading: false\r\n                });\r\n\r\n            });\r\n    }, [category]);\r\n\r\n\r\n    return state;\r\n}\r\n","import React, {useState} from 'react';\r\nimport { AddCategory } from './components/AddCategory';\r\nimport { GifGrid } from './components/GifGrid';\r\n\r\n\r\n// const GifExpertApp = () => {\r\n    \r\nconst GifExpertApp = () => {\r\n    //Esto no sirve porque no permite cambiar porque es una constante\r\n    // const categories = ['One punch', 'Samurai X', 'Dragon Ball'];\r\n\r\n    //Snippet -> useState\r\n    // const [categories, setCategories] = useState(['One punch', 'Samurai X', 'Dragon Ball']);\r\n\r\n    // Dejar solo una categoría para empezar a obtener los gifs desde el api\r\n    const [categories, setCategories] = useState(['Saint Seiya']);\r\n\r\n\r\n    // Tarea 1\r\n        // Agregar un botón para aumentar categorías\r\n        // Crear una función para procesar el evento click\r\n        // Agregar un elemento estático al arreglo\r\n        // Se debe presentar inmediatamente la nueva categoría\r\n\r\n    // Quitamos porque se va a utilizar AddCategory\r\n    // const handleAdd = () => {\r\n    //     // No funciona pero no presenta ni warnings ni errores, el clg si presenta los cambios pero no se renderizan a pesar de ser un const ya que react no sabe que hubieron cambios\r\n    //     // categories.push('Saint Seiya');\r\n    //     // console.log(categories);\r\n\r\n    //     // Esto da un error porque categories es un array y de esta forma lo convertimos en un string con el texto Saint Seiya, JS no se hace problema por cambios de tipos de datos pero al intentar un map() de un string salta el error\r\n    //     // setCategories('Saint Seiya');\r\n\r\n    //     // Forma larga: sacando una copia y agregándole el elemento dado que categorías es inmutable\r\n    //     // let categoriesCopy = [...categories];\r\n    //     // categoriesCopy.push('Saint Seiya');\r\n    //     // setCategories(categoriesCopy);\r\n\r\n    //     //Forma corta: destructurando categories y agregando el elemento, utilizar el setState forza la renderización\r\n    //     // setCategories([...categories, 'Saint Seiya']);\r\n\r\n    //     //En caso de querer una pila. Si se deja con el setCategories anterior solo toma en cuenta el último porque setCategories actualiza con la rederización\r\n    //     // setCategories(['Saint Seiya', ...categories]);\r\n\r\n    //     // También se puede usar un callback, función que puede recibir útil más adelante\r\n    //     //En todos los casos solo funciona correctamente con el primer click porque luego da error porque se repite el key ya que es el mismo nombre de la categoría\r\n    //     setCategories(categs => [...categs, 'Saint Seiya']);\r\n    // }\r\n\r\n    return (\r\n        <>\r\n            <h2>GifExpertApp</h2>\r\n\r\n            {/* Para agregar el componente y visualizarlo, luego servirá para la tarea 3 */}\r\n            {/* <AddCategory /> */}\r\n\r\n            {/* Para poder agregar los elementos desde el componente hijo se envía como prop la función que se quiere ejecutar con el evento */}\r\n            <AddCategory setCategories={ setCategories }/>\r\n\r\n            <hr />\r\n\r\n            {/* Reemplazar por el nuevo AddCategory */}\r\n            {/* <button onClick={ handleAdd }>Agregar categoría</button> */}\r\n\r\n            {/* Presenta todo junto pero por consola se ve que están separados */}\r\n            {/* { categories } */}\r\n\r\n            <ol>\r\n                {/* No funciona porque entre {} se espera una expresión, un valor; el for es un ciclo y no es aceptado\r\n                { for (category in categories) {<li>category</li>}} */}\r\n\r\n                {/* El map devuelve un valor final renderizable directamente pero presenta un error por falta de key o identificador único*/}\r\n                {/* { categories.map(category => <li>{category}</li>) } */}\r\n\r\n                {/* Para solventar el problema se agrega el index como key pero no es recomendable porque si se agregan o eliminan elementos los keys se verán afectados */}\r\n                {/* { categories.map((category, idx) => <li key={idx}>{category}</li>) } */}\r\n\r\n                {/* Se puede utilizar el propio item como key */}\r\n                {/* Dado que el key debe ser único no se podrían repetir elementos, en la mayoría de casos esta información viene de la base de datos y lo que se presentaría sería el id del elemento y su valor. Ej. { categories.map(category => <li key={category.id}>{category.name}</li>) }, así nunca se repetirían */}\r\n                {/* { categories.map(category => <li key={category}>{category}</li>) } */}\r\n\r\n                {/* Reemplazamos el li con el nuevo componente GifGrid */}\r\n                { categories.map(category => \r\n                    <GifGrid \r\n                        key={ category }\r\n                        category={ category } \r\n                    />\r\n                ) }\r\n            </ol>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default GifExpertApp;\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nimport GifExpertApp from './GifExpertApp';\n\n//O no se necesitan o eliminamos, solo quedar index, su css y setupTests\n// import App from './App';\n// import reportWebVitals from './reportWebVitals';\n\n\nReactDOM.render(\n  // Especificar el modo extricto que por ahora causa más problema pero luego se utilizará\n  // <React.StrictMode>\n    <GifExpertApp />,\n  // </React.StrictMode>,\n  document.getElementById('root')\n);\n\n//No se va a utilizar\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n\n// Tarea: \n  // Crear el componente GifExpertApp\n  // Su nombre como título en un h2\n  // Una línea divisoria\n  // Agregar en el index"],"sourceRoot":""}